#include <iostream>
#include <string>
using namespace std;

/****************************************************
 * 1.函数模板定义方式
 * 2.隐式推导必须能够成功推导出来，且不能进行自动类型转换
 * 3.显示指定函数参数
 * 4.函数模板调用与普通函数调用区别
 * 5.自定义类型的函数模板重载实现方式
*****************************************************/


/******************************************
 * 1.函数模板定义 + 函数
 * 定义虚拟类型代表参数类型
 * template<typename T> || template<class T>
 * void function<type>()
******************************************/
template<typename T>
void MySwap(T &a, T &b)
{
    T tmp = a;
    a = b;
    b = tmp;
}
/*******************************************************
 * 函数模板可根据参数类型进行推导，但需保证前后参数类型一致
 * 即必须推到出参数类型才可以进行函数
 * 或显示指定模板参数
********************************************************/
void test01()
{
    int a = 1;
    int b = 2;
    char c = 'a';

    MySwap(a,b);
    MySwap<int>(a,b);

    //MySwap(a,c); 错误类型推导
}

/*****************************************
 * 函数类型推导
 * 函数模板不能单独使用，必须给出类型
 * 即使不调用参数，也要显示指定类型
******************************************/
template<typename T>
void func()
{
    cout << "func 调用过程" << endl;
}
void test02()
{
    // func();
    func<int>();
}

/********************************************************
 * sort函数模板实现
 * 选择排序方法，默认外圈最大，若发现较大数，便进行下标标记
 * 在内圈循环完成找到最大的数，进行交换
*********************************************************/
template<typename T>
void MySort(T arr[], int len)
{
    for( int 1 = 0; i < len; i++){
        int max = i;
        for(int j = i+1; j < len; j++){
            if(arr[max] < arr[j])
                max = j;
        }
        if(max != i)
            MySwap(arr[max],arr[i]);
    }
}

/**************************************************************
 * 普通函数调用时会自动进行类型转换
 * 函数模板显示指定参数时也会自动进行类型转换
 * 隐式推导时不会进行类型转换，因为函数模板推导不出来具体的参数类型
***************************************************************/

/**************************************************************
 * 函数模板的调用规则
 * 1.若函数模板和普通函数都可以实现，则优先普通函数
 * 2.能够通过空模板参数<>指定调用函数模板
 * 3.函数模板能够进行重载操作
 * 4.在参数需要类型转换时，函数模板性能更好，因而会优先调用
**************************************************************/

/*****************************************************
 * 函数模板也会具有局限性
 * 不能针对普遍的自定义类型对象
 * 通过定义指定类型的函数模板，可以优先于普通的函数模板
 * 即模板的重载，特定类型指定具体化的模板
******************************************************/
class Person
{
    public:
        Person(string name,int age):mName(name),mAge(age){};

        string mName;
        int    mAge;
};
// 普通函数模板类型
template<typename T>
bool MyCompare(T &a, T &b)
{
    if(a == b)
        return true;
    else 
        return false;
}
// 自定义类型的具体化模板
template<> bool MyCompare(Person &a, Person &b)
{
    if( a.mName == b.mName && a.mAge == b.mAge)
        return true;
    else 
        return false;
}
